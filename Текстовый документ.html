<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Match-3 — Reveal Background (Full)</title>
<style>
  :root{
    --bg:#071021;
    --panel: rgba(7,12,24,0.6);
    --tile-gap:8px;
    --board-max-width:92vw;
    --accent1:#60a5fa;
    --accent2:#7c3aed;
  }
  *{box-sizing:border-box; -webkit-tap-highlight-color: transparent;}
  body{
    margin:0;
    min-height:100vh;
    display:flex;
    align-items:center;
    justify-content:center;
    background: linear-gradient(180deg,#020617 0%, #071021 100%);
    color:#e6eef8;
    font-family: Inter, Roboto, system-ui, -apple-system, "Segoe UI", Arial;
    padding:18px;
  }

  /* Container */
  .app {
    width:100%;
    max-width:1100px;
    display:flex;
    flex-direction:column;
    gap:14px;
    align-items:center;
  }

  /* Top HUD */
  .hud {
    width:100%;
    display:flex;
    justify-content:space-between;
    align-items:center;
    gap:12px;
  }
  .panel {
    background: var(--panel);
    padding:10px 14px;
    border-radius:12px;
    display:flex;
    gap:12px;
    align-items:center;
    min-width:0;
  }
  .level-title { font-weight:700; font-size:16px; }
  .goal { font-size:13px; color:#dbeafe; opacity:0.95; }

  .progress {
    width:220px; height:10px; background:rgba(255,255,255,0.06); border-radius:999px; overflow:hidden;
  }
  .progress .bar { height:100%; width:0%; background: linear-gradient(90deg,var(--accent1),var(--accent2)); transition:width .4s ease; }

  /* Stage - background frame + board overlay */
  .stage {
    width:100%;
    max-width:var(--board-max-width);
    display:flex;
    justify-content:center;
    align-items:center;
    gap:12px;
    flex-direction:column;
  }

  .bg-frame {
    width:100%;
    max-width:820px;
    aspect-ratio: 1 / 1;
    position:relative;
    border-radius:16px;
    overflow:hidden;
    background:#0b1220;
    box-shadow: 0 14px 40px rgba(2,6,23,0.6);
    touch-action: none;
  }

  /* background image */
  .bg-img {
    position:absolute; inset:0;
    background-size:cover; background-position:center;
    filter: brightness(.6) saturate(.95);
    transition: filter .6s ease;
  }

  /* mask overlay: grid of cover tiles */
  .mask {
    position:absolute; inset:0;
    display:grid;
    pointer-events:none;
  }
  .mask .mcell {
    background: linear-gradient(180deg, rgba(5,8,12,0.92), rgba(10,12,16,0.98));
    transition: opacity .35s ease, transform .35s ease;
    border-radius:8px;
  }
  .mask .mcell.revealed { opacity:0; transform: scale(.98); }

  /* board: absolute positioned tiles for smooth animation */
  .board {
    position:absolute; inset:0;
    padding:12px;
    pointer-events:auto;
  }
  .tile {
    position:absolute;
    width:var(--tile-size);
    height:var(--tile-size);
    border-radius:10px;
    display:flex;
    align-items:center;
    justify-content:center;
    user-select:none;
    touch-action:none;
    transform-origin:center;
    z-index:2;
    transition: transform .28s cubic-bezier(.2,.9,.2,1), opacity .25s ease;
  }
  .tile .gem {
    width:84%;
    height:84%;
    display:block;
    filter: drop-shadow(0 8px 16px rgba(2,6,23,0.55));
    transition: transform .18s ease;
  }
  .tile.dragging { z-index:40; transform: scale(1.06); transition: transform .08s ease; }

  /* disappear animation class */
  .vanish {
    opacity:0 !important;
    transform: scale(.3) translateY(-10px) !important;
    transition: transform .36s ease, opacity .36s ease;
  }

  /* HUD bottom */
  .bottom-hud { width:100%; display:flex; justify-content:space-between; gap:10px; align-items:center; }
  .btn { background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01)); padding:8px 12px; border-radius:10px; border:1px solid rgba(255,255,255,0.04); cursor:pointer; color:#e6eef8; font-weight:600; }
  .small{ font-size:13px; padding:6px 10px; }

  /* level complete overlay */
  .overlay {
  position:absolute; inset:0; display:none; align-items:center; justify-content:center; z-index:999;
  background: transparent;
  padding:24px;
}
  .overlay.show { display:flex; }
  .overlay .card {
    background: transparent; padding:22px; border-radius:14px; text-align:center; max-width:200px; width:100%;
    box-shadow: 0 12px 30px rgba(2,6,23,0.6);
  }
  .overlay h2 { margin:0 0 8px; color:#ffefc8; }
  .overlay p { margin:0 0 16px; color:#dbeafe; opacity:0.95; }

  /* responsive */
  @media (max-width:420px){
    .progress{ width:120px; }
  }
/* --- Мобильная адаптивность для телефонов --- */
@media (max-width:480px){
  body { padding:12px; }
  .stage { width:95vw; max-width:95vw; gap:6px; }
  .bg-frame { width:100%; max-width:95vw; aspect-ratio:1/1; border-radius:12px; }
  .mask { grid-template-columns: repeat(var(--cols,6), 1fr); grid-template-rows: repeat(var(--rows,6), 1fr); gap:4px; }
  .mask .mcell { border-radius:6px; }
  .board { padding:4px; }
    .tile {
    width: calc((100% - (var(--cols,6)-1)*4px)/var(--cols,6));
    height: calc((100% - (var(--rows,6)-1)*4px)/var(--rows,6));
    border-radius:6px;
    display: flex;          /* уже есть, но убедись */
    align-items: center;    /* вертикальное центрирование */
    justify-content: center; /* горизонтальное центрирование */
  }
  .tile .gem {
    width: 90%;   /* подбираешь под размер плитки */
    height: 90%;
    max-width: 100%;
    max-height: 100%;
    object-fit: contain; /* сохраняет пропорции */
  }

  .hud { flex-direction:column; align-items:flex-start; gap:6px; }
  .panel { padding:6px 8px; gap:6px; }
  .level-title { font-size:14px; }
  .goal { font-size:12px; }
  .bottom-hud { flex-direction:column; gap:6px; align-items:stretch; }
  .btn { font-size:13px; padding:6px 10px; }
  .overlay .card { max-width:160px; padding:16px; }
  .overlay h2 { font-size:16px; }
  .overlay p { font-size:12px; }
  .progress { width:120px; }
}

/* Дополнительная адаптивная подстройка под планшеты */
@media (max-width:768px){
  .stage { width:90vw; max-width:90vw; }
  .bg-frame { max-width:90vw; }
  .hud { flex-wrap:wrap; gap:8px; }
  .bottom-hud { flex-direction:row; justify-content:space-between; flex-wrap:wrap; }
}

</style>
</head>
<body>
  <div class="app">
    <div class="hud" style="width:100%;">
      <div class="panel" style="flex:1">
        <div style="display:flex; flex-direction:column; min-width:0">
          <div class="level-title" id="levelName">Level 1</div>
          <div class="goal" id="goalText">Собрать 15 синих кристаллов</div>
        </div>
      </div>

      <div class="panel" style="justify-content:flex-end; gap:14px;">
        <div style="text-align:right; min-width:120px;">
          <div style="font-size:12px; color:#a7c7ff">Собрано</div>
          <div style="font-weight:700" id="collectedText">0 / 15</div>
        </div>
        <div class="progress" title="Reveal progress">
          <div class="bar" id="revealBar"></div>
        </div>
      </div>
    </div>

    <div class="stage">
      <div class="bg-frame" id="bgFrame">
        <div class="bg-img" id="bgImg"></div>
        <div class="mask" id="mask"></div>
        <div class="board" id="board"></div>

        <div class="overlay" id="overlay">
          <div class="card">
            <h2 id="overlayTitle">Уровень пройден!</h2>
            <p id="overlayText">Отлично — фон полностью открыт.</p>
            <div style="display:flex; gap:10px; justify-content:center; margin-top:auto;">
              <button class="btn" id="btnNext">Дальше</button>
              <button class="btn" id="btnReplay">Повторить</button>
            </div>
          </div>
        </div>
      </div>

      <div class="bottom-hud" style="width:100%;">
        <div style="display:flex; gap:10px;">
          <button class="btn small" id="btnHint">Подсказка</button>
          <button class="btn small" id="btnShuffle">Перемешать</button>
          <button class="btn small" id="btnReset">Сброс прогресса</button>
        </div>
        <div style="font-size:13px; color:#cfe0ff">Совет: свайпни или перетащи камень.</div>
      </div>
    </div>
  </div>

<script>
const board = document.querySelector('.bg-frame');
const cols = 8; // количество колонок
const rows = 8; // количество рядов

const tileSize = Math.floor(board.clientWidth / cols);
document.documentElement.style.setProperty('--tile-size', tileSize + 'px');

/*
  Полная версия Match-3:
  - smooth tile movement (absolute positioning + transforms)
  - SVG gem shapes + colors
  - disappear animation + falling with animation
  - reveal background by tile (mask grid)
  - goal: collect N gems of specific color
  - save progress in localStorage
  - overlay on level complete with Next/Replay
*/

/* ----------------- CONFIGURATION ----------------- */
// Уровни — заменяй backgroundUrl на свои прямые ссылки
const levels = [
  { id:1, name:"Sunset Beach", rows:7, cols:7, goal: { colorIndex: 2, count: 18 }, backgroundUrl: "https://yaustal.com/uploads/posts/2024-01/1706421600_ljubitelskie-foto-devushek-0.jpg" },
  { id:2, name:"Forest Trail", rows:8, cols:8, goal: { colorIndex: 4, count: 28 }, backgroundUrl: "https://erovizor.top/wp-content/uploads/2014/06/krasivaja-golaja-devushka-model-4.jpg" },
  { id:3, name:"City Lights", rows:8, cols:8, goal: { colorIndex: 3, count: 36 }, backgroundUrl: "https://yaustal.com/uploads/posts/2024-01/1706421600_ljubitelskie-foto-devushek-0.jpg" }
];

// Количество цветов (должно быть >= максимального используемого colorIndex)
const COLORS_COUNT = 6;

// SVG shapes (paths) и цвета — можно расширить/подменить
const GEM_DEFINITIONS = [
  { color:"#ff5c7c", path: "M50 8 L78 30 L66 70 L34 70 L22 30 Z" }, // красный ромб-пятиуг
  { color:"#ffd166", path: "M50 6 L82 32 L74 74 L26 74 L18 32 Z" }, // желтый
  { color:"#60a5fa", path: "M50 6 L84 36 L66 82 L34 82 L16 36 Z" }, // синий (часто цель)
  { color:"#9b5cf6", path: "M50 6 L86 30 L90 66 L66 86 L34 86 L10 66 L14 30 Z" }, // фиолет
  { color:"#34d399", path: "M50 6 L84 28 L86 64 L50 94 L14 64 L16 28 Z" }, // зеленый
  { color:"#fb7fb8", path: "M50 10 L78 28 L74 62 L50 86 L26 62 L22 28 Z" }  // розовый
];

/* localStorage key */
const STORAGE_KEY = "match3_reveal_progress_v2";

/* ----------------- STATE ----------------- */
let state = {
  levelIdx: 0,
  rows: 7,
  cols: 7,
  board: [],         // 2D array of integers color indices
  tiles: [],         // DOM tile objects with runtime data
  revealedMask: [],  // 2D bool
  collected: 0,
  animating: false,
  pointer: null
};

/* DOM refs */
const boardEl = document.getElementById('board');
const maskEl = document.getElementById('mask');
const bgImgEl = document.getElementById('bgImg');
const levelNameEl = document.getElementById('levelName');
const goalTextEl = document.getElementById('goalText');
const collectedTextEl = document.getElementById('collectedText');
const revealBarEl = document.getElementById('revealBar');
const overlayEl = document.getElementById('overlay');
const overlayTitle = document.getElementById('overlayTitle');
const overlayText = document.getElementById('overlayText');

/* Buttons */
document.getElementById('btnHint').addEventListener('click', onHint);
document.getElementById('btnShuffle').addEventListener('click', ()=>{ 
  shuffleBoard(); 
  prepareGrid();           // пересчёт tileSize и сетки
  renderAllTiles(true);    // рендер плиток
  updateAllTilePositions(false); // устанавливаем transform для каждой плитки
});
document.getElementById('btnReset').addEventListener('click', resetProgress);
document.getElementById('btnNext').addEventListener('click', ()=>{ overlayToggle(false); nextLevel(); });
document.getElementById('btnReplay').addEventListener('click', ()=>{ overlayToggle(false); initLevel(state.levelIdx); });

/* ---------- Persistence ---------- */
function loadProgress(){
  try { return JSON.parse(localStorage.getItem(STORAGE_KEY) || "{}"); }
  catch(e){ return {}; }
}
function saveProgress(prog){
  try { localStorage.setItem(STORAGE_KEY, JSON.stringify(prog)); } catch(e){}
}

/* save current level revealed mask + collected */
function persistLevel(){
  const prog = loadProgress();
  const lid = currentLevel().id;
  prog[lid] = prog[lid] || {};
  prog[lid].revealedMask = state.revealedMask;
  prog[lid].collected = state.collected;
  saveProgress(prog);
}

/* load if exists */
function loadLevelProgress(){
  const prog = loadProgress();
  const lid = currentLevel().id;
  if (prog[lid]){
    if (Array.isArray(prog[lid].revealedMask)) state.revealedMask = prog[lid].revealedMask;
    if (typeof prog[lid].collected === 'number') state.collected = prog[lid].collected;
  }
}

/* ---------- Level helpers ---------- */
function currentLevel(){ return levels[state.levelIdx]; }
function initLevel(index=0){
  // set state from level
  state.levelIdx = index;
  const lvl = currentLevel();
  state.rows = lvl.rows;
  state.cols = lvl.cols;
  state.board = Array.from({length:state.rows}, ()=>Array(state.cols).fill(0));
  state.tiles = [];
  state.revealedMask = Array.from({length:state.rows}, ()=>Array(state.cols).fill(false));
  state.collected = 0;
  state.animating = false;
  // set bg image and texts
  bgImgEl.style.backgroundImage = `url('${lvl.backgroundUrl}')`;
  levelNameEl.textContent = `${lvl.name}`;
  goalTextEl.textContent = `Цель: собрать ${lvl.goal.count} ${colorName(lvl.goal.colorIndex)}`;
  // load saved if any for this level
  loadLevelProgress();
  prepareGrid();
  generateInitialBoard();
  renderAllTiles();
  updateRevealUI();
}

/* human readable color name (for goal text) */
function colorName(idx){
  const names = ["красные","жёлтые","синие","фиолетовые","зелёные","розовые"];
  return names[idx] || ("color"+idx);
}

/* ---------- Prepare grid DOM & sizes ---------- */
function prepareGrid(){
  // mask grid template
  maskEl.style.gridTemplateRows = `repeat(${state.rows}, 1fr)`;
  maskEl.style.gridTemplateColumns = `repeat(${state.cols}, 1fr)`;
  // clear mask and recreate cells
  maskEl.innerHTML = '';
  for (let r=0;r<state.rows;r++){
    for (let c=0;c<state.cols;c++){
      const m = document.createElement('div');
      m.className = 'mcell';
      m.dataset.r = r; m.dataset.c = c;
      maskEl.appendChild(m);
    }
  }
  // compute tile size based on container
  requestAnimationFrame(()=> {
    const frame = document.getElementById('bgFrame');
    const pad = 24; // board padding
    const gap = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tile-gap')) || 8;
    const width = frame.clientWidth - pad*2;
    const tileSize = Math.floor((width - gap*(state.cols-1)) / state.cols);
    document.documentElement.style.setProperty('--tile-size', tileSize + 'px');
    // ensure board container has relative size for absolute tiles
    boardEl.style.width = '100%';
    boardEl.style.height = '100%';
  });
}

/* ---------- Board generation ---------- */
function generateInitialBoard(){
  // generate random board without initial matches
  for (let r=0;r<state.rows;r++){
    for (let c=0;c<state.cols;c++){
      state.board[r][c] = randomNonMatching(r,c);
    }
  }
  // ensure at least one valid move exists (shuffle if necessary)
  let attempts=0;
  while (!hasAnyValidMove() && attempts<300){
    shuffleBoard();
    attempts++;
  }
}

/* pick random color index that doesn't create immediate 3-in-row */
function randomNonMatching(r,c){
  const forbidden = new Set();
  if (c>=2 && state.board[r][c-1] === state.board[r][c-2]) forbidden.add(state.board[r][c-1]);
  if (r>=2 && state.board[r-1][c] === state.board[r-2][c]) forbidden.add(state.board[r-1][c]);
  let tries=0;
  let color;
  do { color = Math.floor(Math.random()*COLORS_COUNT); tries++; } while (forbidden.has(color) && tries<20);
  return color;
}

/* ---------- Rendering tiles (absolute positioned) ---------- */
function renderAllTiles(skipAnim=false){
  // clear existing tile DOM
  boardEl.innerHTML = '';
  state.tiles = [];
  // create tiles for each cell
  for (let r=0;r<state.rows;r++){
    for (let c=0;c<state.cols;c++){
      const colorIndex = state.board[r][c];
      const tile = createTile(r,c,colorIndex);
      boardEl.appendChild(tile.el);
      state.tiles.push(tile);
    }
  }
  // update mask reveal classes
  updateRevealUI();
  // quick check: if skipAnim true, do not animate initial drop
  if (!skipAnim) {
    // animate slight pop for appearance
    state.tiles.forEach((t,idx)=> {
      t.el.style.opacity = '0';
      setTimeout(()=> t.el.style.opacity='1', 20 + (idx%state.cols)*18);
    });
  }
}

/* create single tile DOM element representing gem at r,c */
function createTile(r,c,colorIndex){
  const el = document.createElement('div');
  el.className = 'tile';
  el.style.width = 'var(--tile-size)';
  el.style.height = 'var(--tile-size)';
  el.dataset.r = r; el.dataset.c = c;
  // set initial position
  setTilePositionStyle(el, r, c, 0);

  // gem SVG inner
  const svg = gemSVG(colorIndex);
  el.innerHTML = svg;
  // pointer handlers for drag / swipe
  attachPointerHandlers(el);
  return {el, r, c, colorIndex};
}

/* produce inline SVG string for gem by colorIndex */
function gemSVG(idx){
  const def = GEM_DEFINITIONS[idx % GEM_DEFINITIONS.length];
  // slightly varied transformations for more natural look
  return `<svg class="gem" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="g${idx}" x1="0" x2="1" y1="0" y2="1">
        <stop offset="0" stop-color="${lighten(def.color, 0.18)}"/>
        <stop offset="1" stop-color="${def.color}"/>
      </linearGradient>
      <filter id="sh${idx}" x="-50%" y="-50%" width="200%" height="200%">
        <feDropShadow dx="0" dy="6" stdDeviation="10" flood-color="rgba(2,6,23,0.5)"/>
      </filter>
    </defs>
    <path d="${def.path}" fill="url(#g${idx})" stroke="rgba(255,255,255,0.06)" stroke-width="1.8" filter="url(#sh${idx})" />
  </svg>`;
}

/* tiny color lighten helper */
function lighten(hex, amt){
  // hex like #rrggbb
  const c = hex.replace('#','');
  const r = Math.min(255, parseInt(c.substr(0,2),16) + Math.round(255*amt));
  const g = Math.min(255, parseInt(c.substr(2,2),16) + Math.round(255*amt));
  const b = Math.min(255, parseInt(c.substr(4,2),16) + Math.round(255*amt));
  return `rgb(${r},${g},${b})`;
}

/* position tile DOM using transforms for smooth animation */
function setTilePositionStyle(el, r, c, offsetY=0){
  // compute tile pixel position inside boardEl
  const tileSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tile-size')) || 64;
  const gap = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tile-gap')) || 8;
  const left = c * (tileSize + gap) + 12; // board padding 12 from CSS
  const top = r * (tileSize + gap) + 12;
  el.style.transform = `translate(${left}px, ${top + offsetY}px)`;
}

/* find tile state object for row/col */
function tileObjAt(r,c){
  return state.tiles.find(t => parseInt(t.el.dataset.r) === r && parseInt(t.el.dataset.c) === c);
}

/* update all tile positions according to state.board (with optional animation offsets) */
function updateAllTilePositions(animation=true){
  const tileSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tile-size')) || 64;
  for (let t of state.tiles){
    // find its current r,c from board by matching element reference? we store dataset
    const r = parseInt(t.el.dataset.r), c = parseInt(t.el.dataset.c);
    setTilePositionStyle(t.el, r, c, 0);
    if (!animation){
      t.el.style.transition = 'none';
      requestAnimationFrame(()=> t.el.style.transition = '');
    }
  }
}

/* ---------- Input & Dragging ---------- */
function attachPointerHandlers(el){
  el.addEventListener('pointerdown', onPointerDown);
  el.style.touchAction = 'none';
}
let pointerState = null;

function onPointerDown(e){
  if (state.animating) return;
  const el = e.currentTarget;
  el.setPointerCapture(e.pointerId);
  const startX = e.clientX, startY = e.clientY;
  const startR = parseInt(el.dataset.r), startC = parseInt(el.dataset.c);
  pointerState = { el, startX, startY, startR, startC, id: e.pointerId, moved:false };

  el.classList.add('dragging');

  function onMove(ev){
    if (!pointerState) return;
    const dx = ev.clientX - pointerState.startX;
    const dy = ev.clientY - pointerState.startY;
    // visual drag: move by transform on element
    pointerState.el.style.transform = pointerState.el.style.transform + ` translate(${dx}px, ${dy}px)`;
    pointerState.moved = Math.hypot(dx,dy) > 12;
  }
  function onUp(ev){
    if (!pointerState) return;
    const dx = ev.clientX - pointerState.startX;
    const dy = ev.clientY - pointerState.startY;
    pointerState.el.classList.remove('dragging');
    pointerState.el.releasePointerCapture(pointerState.id);

    // calculate swipe direction to neighbor if big enough movement
    const adx = Math.abs(dx), ady = Math.abs(dy);
    let targetR = pointerState.startR, targetC = pointerState.startC;
    if (Math.max(adx, ady) > 18){
      if (adx > ady){
        targetC = (dx > 0) ? pointerState.startC + 1 : pointerState.startC - 1;
      } else {
        targetR = (dy > 0) ? pointerState.startR + 1 : pointerState.startR - 1;
      }
      // bounds check
      if (targetR>=0 && targetR<state.rows && targetC>=0 && targetC<state.cols){
        trySwap(pointerState.startR, pointerState.startC, targetR, targetC);
      } else {
        // revert visual
        updateAllTilePositions();
      }
    } else {
      // small movement: treat as tap - try to select neighbor by next tap (not implemented selection)
      updateAllTilePositions();
    }

    // cleanup listeners
    window.removeEventListener('pointermove', onMove);
    window.removeEventListener('pointerup', onUp);
    pointerState = null;
  }

  window.addEventListener('pointermove', onMove);
  window.addEventListener('pointerup', onUp);
}

/* ---------- Match detection ---------- */
/* find all cells that are in matches (len>=3) */
function findMatches(board){
  const rows = state.rows, cols = state.cols;
  const mark = Array.from({length:rows}, ()=>Array(cols).fill(false));
  // horizontal
  for (let r=0;r<rows;r++){
    let runColor = board[r][0], runStart = 0, runLen = 1;
    for (let c=1;c<=cols;c++){
      const color = c<cols ? board[r][c] : null;
      if (color === runColor) runLen++;
      else {
        if (runLen>=3) for (let k=runStart;k<runStart+runLen;k++) mark[r][k]=true;
        runColor = color; runStart = c; runLen = 1;
      }
    }
  }
  // vertical
  for (let c=0;c<cols;c++){
    let runColor = board[0][c], runStart = 0, runLen = 1;
    for (let r=1;r<=rows;r++){
      const color = r<rows ? board[r][c] : null;
      if (color === runColor) runLen++;
      else {
        if (runLen>=3) for (let k=runStart;k<runStart+runLen;k++) mark[k][c]=true;
        runColor = color; runStart = r; runLen = 1;
      }
    }
  }
  const matches = [];
  for (let r=0;r<rows;r++) for (let c=0;c<cols;c++) if (mark[r][c]) matches.push({r,c});
  return matches;
}

/* ---------- Swap validation / action ---------- */
let swapLock = false;
async function trySwap(r1,c1,r2,c2){
  if (swapLock || state.animating) return false;
  if (Math.abs(r1-r2) + Math.abs(c1-c2) !== 1) return false;
  swapLock = true;
  swapBoardCells(r1,c1,r2,c2);
  // animate swap visually: move both tiles
  animateSwapTiles(r1,c1,r2,c2);
  await sleep(220);
  const matches = findMatches(state.board);
  if (matches.length === 0){
    // revert with bounce
    animateSwapTiles(r1,c1,r2,c2, true);
    await sleep(220);
    swapBoardCells(r1,c1,r2,c2); // back
    renderAllTiles(false);
    swapLock = false;
    return false;
  }
  // valid: resolve cascades
  await resolveCascades();
  swapLock = false;
  return true;
}

function swapBoardCells(r1,c1,r2,c2){
  const tmp = state.board[r1][c1];
  state.board[r1][c1] = state.board[r2][c2];
  state.board[r2][c2] = tmp;
  // swap datasets on tile DOMs
  const t1 = tileObjAt(r1,c1), t2 = tileObjAt(r2,c2);
  if (t1) { t1.el.dataset.r = r1; t1.el.dataset.c = c1; }
  if (t2) { t2.el.dataset.r = r2; t2.el.dataset.c = c2; }
}

/* animate two tiles swapping by moving their transforms; revert flag for bounce */
function animateSwapTiles(r1,c1,r2,c2, revert=false){
  const t1 = tileObjAt(r1,c1), t2 = tileObjAt(r2,c2);
  if (!t1 || !t2) return;
  // compute positions
  const tileSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tile-size')) || 64;
  const gap = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tile-gap')) || 8;
  const left1 = c1*(tileSize+gap)+12, top1 = r1*(tileSize+gap)+12;
  const left2 = c2*(tileSize+gap)+12, top2 = r2*(tileSize+gap)+12;
  // set transform directly
  t1.el.style.transition = 'transform .2s cubic-bezier(.2,.9,.2,1)';
  t2.el.style.transition = 'transform .2s cubic-bezier(.2,.9,.2,1)';
  t1.el.style.transform = `translate(${left2}px, ${top2}px)`;
  t2.el.style.transform = `translate(${left1}px, ${top1}px)`;
  if (revert){
    setTimeout(()=> {
      // bounce: small translate then back
      t1.el.style.transform = `translate(${left2}px, ${top2}px) scale(.96)`;
      t2.el.style.transform = `translate(${left1}px, ${top1}px) scale(.96)`;
      setTimeout(()=> { updateAllTilePositions(true); }, 120);
    }, 180);
  } else {
    // after swap, update dataset positions
    setTimeout(()=> {
      // swap dataset r/c values to match new board positions in DOM
      const a = t1.el.dataset, b = t2.el.dataset;
      const tmpR = a.r, tmpC = a.c;
      a.r = b.r; a.c = b.c;
      b.r = tmpR; b.c = tmpC;
      updateAllTilePositions(true);
    }, 220);
  }
}

/* ---------- Resolve cascades: remove matches, gravity, refill ---------- */
async function resolveCascades(){
  state.animating = true;
  while (true){
    const matches = findMatches(state.board);
    if (matches.length === 0) break;
    // remove matched tiles visually
    await removeMatches(matches);
    // apply gravity & refill
    await applyGravityAndRefill();
    persistLevel();
    updateRevealUI();
    await sleep(120);
  }
  state.animating = false;
  // after cascades, ensure at least one valid move, else shuffle
  if (!hasAnyValidMove()){
    shuffleBoard();
    renderAllTiles(true);
    await sleep(120);
  }
  checkWin();
}

/* animate removal of matched cells and update collected & reveal mask */
function removeMatches(cells){
  return new Promise(res=>{
    // dedupe by r,c
    const unique = [];
    const seen = new Set();
    for (const cell of cells){
      const key = `${cell.r},${cell.c}`;
      if (!seen.has(key)){ unique.push(cell); seen.add(key); }
    }
    // animate tiles: find tile DOMs at these positions, add vanish class
    unique.forEach(({r,c})=>{
      const t = tileObjAt(r,c);
      if (t && t.el){
        t.el.classList.add('vanish');
      }
      // reveal mask cell
      if (!state.revealedMask[r][c]) state.revealedMask[r][c] = true;
      // update collected if matches goal color
      const colorIndex = state.board[r][c];
      if (colorIndex === currentLevel().goal.colorIndex) state.collected++;
    });

    // update UI texts immediately
    updateRevealUI();
    // after animation, remove DOM nodes & set board cells to null
    setTimeout(()=>{
      // remove DOM elements for vanished tiles and set board null
      unique.forEach(({r,c})=>{
        const t = tileObjAt(r,c);
        if (t && t.el && t.el.parentElement) t.el.parentElement.removeChild(t.el);
        state.board[r][c] = null;
        // also remove from state.tiles array
        state.tiles = state.tiles.filter(tt => tt.el !== (t && t.el));
      });
      res();
    }, 380);
  });
}

/* gravity & refill: columns fall down, new tiles spawn above and fall */
function applyGravityAndRefill(){
  return new Promise(async res=>{
    const tileSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tile-size')) || 64;
    const gap = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tile-gap')) || 8;
    // for each column, compact non-null downward
    for (let c=0;c<state.cols;c++){
      let write = state.rows - 1;
      for (let r=state.rows-1;r>=0;r--){
        if (state.board[r][c] !== null && state.board[r][c] !== undefined){
          // move value to write position if needed
          if (write !== r){
            state.board[write][c] = state.board[r][c];
            // move DOM tile: find tile with dataset r,c and update dataset to new r
            const t = tileObjAt(r,c);
            if (t){
              t.el.dataset.r = write; t.el.dataset.c = c;
              // animate falling: set transform to target position
              setTilePositionStyle(t.el, write, c, 0);
            }
            state.board[r][c] = null;
          }
          write--;
        }
      }
      // now fill top empty spaces with new random tiles and position above and let them fall
      for (let r = write; r >= 0; r--){
        const color = Math.floor(Math.random()*COLORS_COUNT);
        state.board[r][c] = color;
        const tile = createTile(r,c,color);
        // position tile above with offset
        const startOffset = - ( (write - r + 1) * (tileSize + gap) + 20 );
        setTilePositionStyle(tile.el, r, c, startOffset);
        tile.el.style.opacity = '0';
        boardEl.appendChild(tile.el);
        state.tiles.push(tile);
        // animate fall (opacity + translate to correct pos)
        requestAnimationFrame(()=>{
          tile.el.style.transition = 'transform .34s cubic-bezier(.2,.9,.2,1), opacity .28s ease';
          tile.el.style.opacity = '1';
          setTilePositionStyle(tile.el, r, c, 0);
        });
        await sleep(22); // stagger drop a little
      }
    }
    // after spawn, small wait for all animations to complete
    await sleep(360);
    // ensure all tile positions updated
    updateAllTilePositions(true);
    res();
  });
}

/* ---------- Utility: shuffle board ---------- */
function shuffleBoard(){
  const flat = [];
  for (let r=0;r<state.rows;r++) for (let c=0;c<state.cols;c++) flat.push(state.board[r][c]===null? Math.floor(Math.random()*COLORS_COUNT): state.board[r][c]);
  // shuffle
  for (let i=flat.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [flat[i],flat[j]]=[flat[j],flat[i]];}
  for (let r=0, k=0;r<state.rows;r++) for (let c=0;c<state.cols;c++) state.board[r][c]=flat[k++];
  // Remove accidental initial matches
  for (let r=0;r<state.rows;r++) for (let c=0;c<state.cols;c++) if (createsMatchAt(r,c)) state.board[r][c] = randomNonMatching(r,c);
  // re-render
  renderAllTiles(true);
}

/* check if placing current color at r,c creates a 3+ (used for shuffle cleanup) */
function createsMatchAt(r,c){
  const color = state.board[r][c];
  // horizontal
  let len=1;
  for (let i=c-1;i>=0 && state.board[r][i]===color;i--) len++;
  for (let i=c+1;i<state.cols && state.board[r][i]===color;i++) len++;
  if (len>=3) return true;
  // vertical
  len=1;
  for (let i=r-1;i>=0 && state.board[i][c]===color;i--) len++;
  for (let i=r+1;i<state.rows && state.board[i][c]===color;i++) len++;
  return len>=3;
}

/* ---------- Moves availability ---------- */
function hasAnyValidMove(){
  for (let r=0;r<state.rows;r++){
    for (let c=0;c<state.cols;c++){
      const dirs = [[0,1],[1,0],[-1,0],[0,-1]];
      for (const [dr,dc] of dirs){
        const nr=r+dr, nc=c+dc;
        if (nr<0||nr>=state.rows||nc<0||nc>=state.cols) continue;
        swapBoardCells(r,c,nr,nc);
        const matches = findMatches(state.board);
        swapBoardCells(r,c,nr,nc);
        if (matches.length>0) return true;
      }
    }
  }
  return false;
}

/* ---------- Hint: simple best-first ---------- */
function onHint(){
  const best = findBestMoveSimple();
  if (!best){
    alert("Нет доступных ходов — выполняется перемешивание.");
    shuffleBoard();
    return;
  }
  // highlight two tiles by scale animation
  const a = tileObjAt(best.from[0], best.from[1]);
  const b = tileObjAt(best.to[0], best.to[1]);
  if (a) { a.el.style.transform += ' scale(1.08)'; setTimeout(()=> updateAllTilePositions(), 700); }
  if (b) { b.el.style.transform += ' scale(1.08)'; setTimeout(()=> updateAllTilePositions(), 700); }
}
function findBestMoveSimple(){
  for (let r=0;r<state.rows;r++){
    for (let c=0;c<state.cols;c++){
      const dirs = [[0,1],[1,0],[-1,0],[0,-1]];
      for (const [dr,dc] of dirs){
        const nr=r+dr, nc=c+dc;
        if (nr<0||nr>=state.rows||nc<0||nc>=state.cols) continue;
        swapBoardCells(r,c,nr,nc);
        const matches = findMatches(state.board);
        swapBoardCells(r,c,nr,nc);
        if (matches.length>0) return {from:[r,c], to:[nr,nc]};
      }
    }
  }
  return null;
}

/* ---------- Win check ---------- */
function checkWin(){
  const lvl = currentLevel();
  if (state.collected >= lvl.goal.count){
    // очистка поля и маски
    boardEl.innerHTML = '';
    maskEl.innerHTML = '';
    // фон становится полностью виден
    bgImgEl.style.filter = 'brightness(1) saturate(1)';

    // показать сообщение
    overlayTitle.textContent = "Уровень пройден!";
    overlayText.textContent = "Фон полностью открыт 🎉";
    overlayToggle(true);
  }
}
function showLevelComplete(){
  // reveal background fully visually, disable interactions
  bgImgEl.style.filter = 'brightness(1) saturate(1.05)';
  overlayToggle(true);
}
function overlayToggle(show){
  if (show) overlayEl.classList.add('show'); else overlayEl.classList.remove('show');
}

/* next level */
function nextLevel(){
  if (state.levelIdx+1 < levels.length) initLevel(state.levelIdx+1);
  else {
    overlayTitle.textContent = "Поздравляем!";
    overlayText.textContent = "Вы прошли все уровни. Можно начать сначала.";
    overlayToggle(true);
    // reset to first after a small delay if user presses next again => replay handled separately
  }
}

/* reset progress */
function resetProgress(){
  if (!confirm("Сбросить прогресс?")) return;
  localStorage.removeItem(STORAGE_KEY);
  initLevel(0);
}

/* ---------- UI update: reveal mask / collected / progress bar ---------- */
function updateRevealUI(){
  // update mask DOM
  for (let r=0;r<state.rows;r++){
    for (let c=0;c<state.cols;c++){
      const idx = r*state.cols + c;
      const cell = maskEl.children[idx];
      if (!cell) continue;
      if (state.revealedMask[r][c]) cell.classList.add('revealed'); else cell.classList.remove('revealed');
    }
  }
  // update collected text
  collectedTextEl.textContent = `${state.collected} / ${currentLevel().goal.count}`;
  // progress percent
  const total = state.rows * state.cols;
  let revealed = 0;
  for (let r=0;r<state.rows;r++) for (let c=0;c<state.cols;c++) if (state.revealedMask[r][c]) revealed++;
  const pct = Math.round((revealed/total)*100);
  revealBarEl.style.width = pct + '%';
}

/* ---------- Utility helpers ---------- */
function sleep(ms){ return new Promise(res => setTimeout(res, ms)); }

/* random helper for board generation */
function randInt(n){ return Math.floor(Math.random()*n); }

/* find tile object by dataset r/c */
function tileObjAt(r,c){
  return state.tiles.find(t => parseInt(t.el.dataset.r) === r && parseInt(t.el.dataset.c) === c);
}

/* ---------- Start on load ---------- */
window.addEventListener('load', ()=> {
  // try to restore last unlocked level from storage (highest key)
  const prog = loadProgress();
  const keys = Object.keys(prog).map(k=>parseInt(k)).filter(n=>!isNaN(n));
  if (keys.length>0){
    const maxId = Math.max(...keys);
    const idx = levels.findIndex(l=>l.id===maxId);
    if (idx>=0) initLevel(idx); else initLevel(0);
  } else initLevel(0);
});

/* keep saving before unload */
window.addEventListener('beforeunload', ()=>{ persistLevel(); });

</script>
</body>
</html>
