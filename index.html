<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Match-3: Glass Grid</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
<style>
/* --- Design Variables --- */
:root {
  --bg-color: #0d1117;
  --card-bg-light: rgba(255, 255, 255, 0.08);
  --card-bg-dark: rgba(0, 0, 0, 0.1);
  --border-color: rgba(255, 255, 255, 0.15);
  --text-color-primary: #e6eef8;
  --text-color-secondary: #a0a6b4;
  --font-family-base: 'Roboto Mono', monospace;
  --tile-gap: 8px;
  --border-radius-lg: 16px;
  --border-radius-sm: 8px;
}

body {
  margin: 0;
  padding: 1.5rem;
  min-height: 100vh;
  display: flex;
  align-items: center;
  justify-content: center;
  background: var(--bg-color);
  color: var(--text-color-primary);
  font-family: var(--font-family-base);
  -webkit-font-smoothing: antialiased;
}

/* --- Main Layout --- */
.app {
  width: 100%;
  max-width: 1100px;
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
  align-items: center;
  min-height: calc(100vh - 3rem);
  position: relative;
}

/* --- HUD (Top Panel) --- */
.hud {
  width: 80%;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.panel {
  background: var(--card-bg-light);
  border: 1px solid var(--border-color);
  backdrop-filter: blur(12px);
  padding: 1rem;
  border-radius: var(--border-radius-lg);
  display: flex;
  align-items: center;
  gap: 1rem;
  width: 100%;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}

.level-info {
  flex-grow: 1;
  min-width: 0;
}

.level-title {
  font-weight: 700;
  font-size: 1.25rem;
  margin: 0;
  color: #c8d3e6;
}

.goal-text {
  font-size: 0.875rem;
  color: var(--text-color-secondary);
  opacity: 0.9;
  margin: 0;
}

.progress-info {
  text-align: right;
  min-width: 80px;
}

.collected-text {
  font-weight: 700;
  font-size: 1rem;
}

.progress-bar-container {
  width: 100%;
  max-width: 200px;
  height: 8px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 999px;
  overflow: hidden;
  margin-left: auto;
}

.progress-bar-fill {
  height: 100%;
  width: 0%;
  background: linear-gradient(90deg, #60e3fa, #3a94ed);
  transition: width 0.4s ease;
}

/* --- Game Stage --- */
.stage {
  width: 100%;
  max-width: 900px;
  aspect-ratio: 1/1;
  position: relative;
  touch-action: none;
  border-radius: var(--border-radius-lg);
  overflow: hidden;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4), inset 0 0 12px rgba(255, 255, 255, 0.05);
}

.bg-frame {
  position: absolute;
  inset: 0;
  background-size: cover;
  background-position: center;
  filter: brightness(0.6) saturate(0.8);
  transition: filter 0.8s ease;
}

.mask-grid {
  position: absolute;
  inset: 0;
  display: grid;
  padding: var(--tile-gap);
  gap: var(--tile-gap);
  transition: opacity 0.5s ease;
}

.mask-grid.hidden {
  opacity: 0;
}

.mask-cell {
  background: rgba(16, 21, 31, 0.95);
  transition: opacity 0.4s ease-out, transform 0.4s ease-out;
  border-radius: var(--border-radius-sm);
}

.mask-cell.revealed {
  opacity: 0;
  transform: scale(0.95);
}

/* --- CORE: CSS Grid Board --- */
.board {
  position: absolute;
  inset: 0;
  display: grid;
  padding: var(--tile-gap);
  gap: var(--tile-gap);
  pointer-events: auto;
  grid-template-columns: repeat(var(--cols), 1fr);
  grid-template-rows: repeat(var(--rows), 1fr);
  transition: opacity 0.5s ease;
}

.board.hidden {
  opacity: 0;
}

/* --- Tiles and Gems --- */
.tile {
  display: flex;
  align-items: center;
  justify-content: center;
  user-select: none;
  touch-action: none;
  transition: transform 0.3s cubic-bezier(0.2, 0.9, 0.2, 1);
  z-index: 10;
}

.tile .gem {
  width: 90%;
  height: 90%;
  display: block;
  transform: scale(1);
  filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.5));
  transition: transform 0.2s ease;
}

/* --- Animations --- */
.vanish {
  animation: vanish 0.4s cubic-bezier(0.2, 0.9, 0.2, 1) forwards;
}

@keyframes vanish {
  0% { transform: scale(1); opacity: 1; }
  100% { transform: scale(0.2) rotate(45deg); opacity: 0; }
}

/* --- Buttons --- */
.button-group {
  width: 100%;
  display: flex;
  gap: 12px;
}

.btn {
  background: var(--card-bg-light);
  border: 1px solid var(--border-color);
  backdrop-filter: blur(12px);
  padding: 10px 18px;
  border-radius: var(--border-radius-sm);
  cursor: pointer;
  color: var(--text-color-primary);
  font-weight: 700;
  font-size: 0.875rem;
  flex: 1;
  transition: transform 0.15s ease, background 0.15s ease;
}

.btn:hover {
  background: rgba(255, 255, 255, 0.12);
}

.btn:active {
  transform: scale(0.98);
}

.win-buttons {
  position: absolute;
  bottom: 1.5rem;
  left: 50%;
  transform: translateX(-50%);
  width: 100%;
  max-width: 350px;
  display: none;
  z-index: 1000;
}

/* --- Overlay --- */
.overlay {
  position: absolute;
  inset: 0;
  background: transparent;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 999;
  padding: 1.5rem;
  display: none;
  opacity: 0;
  transition: opacity 0.4s ease;
}

.overlay.show {
  display: flex;
  opacity: 1;
}

.overlay-card {
  background: transparent;
  border: 1px solid var(--border-color);
  padding: 1.5rem;
  border-radius: var(--border-radius-lg);
  text-align: center;
  max-width: 150px;
  box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
  transform: scale(0.9);
  transition: transform 0.3s cubic-bezier(0.2, 0.9, 0.2, 1);
}

.overlay.show .overlay-card {
  transform: scale(1);
}

.overlay-title {
  margin: 0 0 8px;
  color: blue;
  font-size: 15px;
}

.overlay-text {
  margin: 0;
  color: #ed82ff;
  font-size: 15px;
}

/* Responsive layout for tablets/desktops */
@media (min-width: 768px) {
  .hud {
    flex-direction: row;
    align-items: center;
  }
  .panel {
    padding: 1rem 1.5rem;
  }
}

@media (max-width: 767px) {
  .panel {
    padding: 0.75rem 1rem;
    gap: 0.75rem;
  }
  .level-title {
    font-size: 1rem;
  }
  .goal-text {
    font-size: 0.75rem;
  }
  .collected-text {
    font-size: 0.875rem;
  }
}
</style>
</head>
<body>
  <div class="app">
    <div class="hud">
      <div class="panel">
        <div class="level-info">
          <div class="level-title" id="levelName"></div>
          <div class="goal-text" id="goalText"></div>
        </div>
      </div>
      <div class="panel">
        <div class="progress-info">
          <div class="collected-text" id="collectedText"></div>
        </div>
        <div class="progress-bar-container">
          <div class="progress-bar-fill" id="revealBar"></div>
        </div>
      </div>
    </div>

    <div class="stage">
      <div class="bg-frame" id="bgImg"></div>
      <div class="mask-grid" id="mask"></div>
      <div class="board" id="board"></div>
      
      <div class="overlay" id="overlay">
        <div class="overlay-card">
          <h2 class="overlay-title" id="overlayTitle"></h2>
          <p class="overlay-text" id="overlayText"></p>
        </div>
      </div>
    </div>
    
    <div class="button-group">
      <button class="btn" id="btnHint">–ü–æ–¥—Å–∫–∞–∑–∫–∞</button>
      <button class="btn" id="btnShuffle">–ü–µ—Ä–µ–º–µ—à–∞—Ç—å</button>
      <button class="btn" id="btnReset">–°–±—Ä–æ—Å</button>
    </div>

    <div class="win-buttons" id="winButtons">
      <button class="btn" id="btnReplay">–ü–æ–≤—Ç–æ—Ä–∏—Ç—å</button>
      <button class="btn" id="btnNext">–î–∞–ª—å—à–µ</button>
    </div>
  </div>

  <script>
    /* ----------------- Game Configuration ----------------- */
    const levels = [
      { id: 1, name: "–ì–æ—Ä–æ–¥—Å–∫–æ–π –∑–∞–∫–∞—Ç", rows: 7, cols: 7, goal: { colorIndex: 2, count: 18 }, backgroundUrl: "https://yaustal.com/uploads/posts/2024-01/1706421600_ljubitelskie-foto-devushek-0.jpg" },
      { id: 2, name: "–õ–µ—Å–Ω–∞—è —Ç—Ä–æ–ø–∞", rows: 8, cols: 8, goal: { colorIndex: 4, count: 28 }, backgroundUrl: "https://erovizor.top/wp-content/uploads/2014/06/krasivaja-golaja-devushka-model-4.jpg" },
      { id: 3, name: "–ù–æ—á–Ω–æ–π –≥–æ—Ä–æ–¥", rows: 8, cols: 8, goal: { colorIndex: 3, count: 36 }, backgroundUrl: "https://yaustal.com/uploads/posts/2024-01/1706421600_ljubitelskie-foto-devushek-0.jpg" }
    ];
    const COLORS_COUNT = 6;
    const GEM_DEFINITIONS = [
      { color: "#ff5c7c", path: "M50 8 L78 30 L66 70 L34 70 L22 30 Z" },
      { color: "#ffd166", path: "M50 6 L82 32 L74 74 L26 74 L18 32 Z" },
      { color: "#60a5fa", path: "M50 6 L84 36 L66 82 L34 82 L16 36 Z" },
      { color: "#9b5cf6", path: "M50 6 L86 30 L90 66 L66 86 L34 86 L10 66 L14 30 Z" },
      { color: "#34d399", path: "M50 6 L84 28 L86 64 L50 94 L14 64 L16 28 Z" },
      { color: "#fb7fb8", path: "M50 10 L78 28 L74 62 L50 86 L26 62 L22 28 Z" }
    ];
    const STORAGE_KEY = "match3_glass_grid_v4";

    /* ----------------- Game State & DOM References ----------------- */
    let state = {
      levelIdx: 0,
      rows: 7,
      cols: 7,
      board: [],
      tiles: new Map(),
      revealedMask: [],
      collected: 0,
      animating: false,
    };

    const boardEl = document.getElementById('board');
    const maskEl = document.getElementById('mask');
    const bgImgEl = document.getElementById('bgImg');
    const levelNameEl = document.getElementById('levelName');
    const goalTextEl = document.getElementById('goalText');
    const collectedTextEl = document.getElementById('collectedText');
    const revealBarEl = document.getElementById('revealBar');
    const overlayEl = document.getElementById('overlay');
    const overlayCard = document.querySelector('.overlay-card');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');
    const winButtonsEl = document.getElementById('winButtons');

    /* Buttons */
    document.getElementById('btnHint').addEventListener('click', onHint);
    document.getElementById('btnShuffle').addEventListener('click', shuffleBoard);
    document.getElementById('btnReset').addEventListener('click', resetProgress);
    document.getElementById('btnNext').addEventListener('click', () => { overlayToggle(false); nextLevel(); });
    document.getElementById('btnReplay').addEventListener('click', () => { overlayToggle(false); initLevel(state.levelIdx); });

    /* ---------- Persistence ---------- */
    function loadProgress() {
      try { return JSON.parse(localStorage.getItem(STORAGE_KEY) || "{}"); } catch (e) { return {}; }
    }

    function saveProgress(prog) {
      try { localStorage.setItem(STORAGE_KEY, JSON.stringify(prog)); } catch (e) {}
    }

    function persistLevel() {
      const prog = loadProgress();
      const lid = currentLevel().id;
      prog[lid] = {
        revealedMask: state.revealedMask,
        collected: state.collected
      };
      saveProgress(prog);
    }

    function loadLevelProgress() {
      const prog = loadProgress();
      const lid = currentLevel().id;
      if (prog[lid]) {
        if (Array.isArray(prog[lid].revealedMask)) state.revealedMask = prog[lid].revealedMask;
        if (typeof prog[lid].collected === 'number') state.collected = prog[lid].collected;
      }
    }

    /* ---------- Level helpers ---------- */
    function currentLevel() { return levels[state.levelIdx]; }
    
    function colorName(idx) {
      const names = ["–∫—Ä–∞—Å–Ω—ã–µ", "–∂—ë–ª—Ç—ã–µ", "—Å–∏–Ω–∏–µ", "—Ñ–∏–æ–ª–µ—Ç–æ–≤—ã–µ", "–∑–µ–ª—ë–Ω—ã–µ", "—Ä–æ–∑–æ–≤—ã–µ"];
      return names[idx] || "—Ü–≤–µ—Ç " + (idx + 1);
    }

    function initLevel(index = 0) {
      state.levelIdx = index;
      const lvl = currentLevel();
      state.rows = lvl.rows;
      state.cols = lvl.cols;
      state.board = Array.from({ length: state.rows }, () => Array(state.cols).fill(0));
      state.tiles = new Map();
      state.revealedMask = Array.from({ length: state.rows }, () => Array(state.cols).fill(false));
      state.collected = 0;
      state.animating = false;

      bgImgEl.style.backgroundImage = `url('${lvl.backgroundUrl}')`;
      bgImgEl.style.filter = '';
      levelNameEl.textContent = `${lvl.name}`;
      goalTextEl.textContent = `–¶–µ–ª—å: —Å–æ–±—Ä–∞—Ç—å ${lvl.goal.count} ${colorName(lvl.goal.colorIndex)}`;
      
      loadLevelProgress();
      
      // Setup CSS Grid
      boardEl.style.setProperty('--cols', state.cols);
      boardEl.style.setProperty('--rows', state.rows);
      maskEl.style.gridTemplateColumns = `repeat(${state.cols}, 1fr)`;
      maskEl.style.gridTemplateRows = `repeat(${state.rows}, 1fr)`;

      boardEl.classList.remove('hidden');
      maskEl.classList.remove('hidden');

      generateInitialBoard();
      renderAllTiles();
      updateRevealUI();
    }
    
    /* ---------- Board Generation ---------- */
    function generateInitialBoard() {
      for (let r = 0; r < state.rows; r++) {
        for (let c = 0; c < state.cols; c++) {
          state.board[r][c] = randomNonMatching(r, c);
        }
      }
      let attempts = 0;
      while (!hasAnyValidMove() && attempts < 300) {
        shuffleBoard();
        attempts++;
      }
    }

    function randomNonMatching(r, c) {
      const forbidden = new Set();
      if (c >= 2 && state.board[r][c - 1] === state.board[r][c - 2]) forbidden.add(state.board[r][c - 1]);
      if (r >= 2 && state.board[r - 1][c] === state.board[r - 2][c]) forbidden.add(state.board[r - 1][c]);
      let color;
      do {
        color = Math.floor(Math.random() * COLORS_COUNT);
      } while (forbidden.has(color));
      return color;
    }

    /* ---------- Rendering Tiles (CSS Grid based) ---------- */
    function renderAllTiles() {
      boardEl.innerHTML = '';
      state.tiles.clear();
      for (let r = 0; r < state.rows; r++) {
        for (let c = 0; c < state.cols; c++) {
          const colorIndex = state.board[r][c];
          const tile = createTile(r, c, colorIndex);
          boardEl.appendChild(tile.el);
          state.tiles.set(`${r},${c}`, tile);
        }
      }
      // Re-render mask cells as well
      maskEl.innerHTML = '';
      for (let r = 0; r < state.rows; r++) {
        for (let c = 0; c < state.cols; c++) {
          const m = document.createElement('div');
          m.className = 'mask-cell';
          if (state.revealedMask[r][c]) m.classList.add('revealed');
          maskEl.appendChild(m);
        }
      }
    }
    
    function createTile(r, c, colorIndex) {
      const el = document.createElement('div');
      el.className = 'tile';
      el.dataset.r = r;
      el.dataset.c = c;
      el.dataset.color = colorIndex;
      el.style.gridRow = `${r + 1} / span 1`;
      el.style.gridColumn = `${c + 1} / span 1`;
      const svg = gemSVG(colorIndex);
      el.innerHTML = svg;
      attachPointerHandlers(el);
      return { el, r, c, colorIndex };
    }

    function gemSVG(idx) {
      const def = GEM_DEFINITIONS[idx % GEM_DEFINITIONS.length];
      return `<svg class="gem" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
        <defs>
          <linearGradient id="g${idx}" x1="0" x2="1" y1="0" y2="1">
            <stop offset="0" stop-color="${lighten(def.color, 0.18)}"/>
            <stop offset="1" stop-color="${def.color}"/>
          </linearGradient>
          <filter id="sh${idx}" x="-50%" y="-50%" width="200%" height="200%">
            <feDropShadow dx="0" dy="6" stdDeviation="10" flood-color="rgba(2,6,23,0.5)"/>
          </filter>
        </defs>
        <path d="${def.path}" fill="url(#g${idx})" stroke="rgba(255,255,255,0.06)" stroke-width="1.8" filter="url(#sh${idx})" />
      </svg>`;
    }

    function lighten(hex, amt) {
      const c = hex.replace('#', '');
      const r = Math.min(255, parseInt(c.substr(0, 2), 16) + Math.round(255 * amt));
      const g = Math.min(255, parseInt(c.substr(2, 2), 16) + Math.round(255 * amt));
      const b = Math.min(255, parseInt(c.substr(4, 2), 16) + Math.round(255 * amt));
      return `rgb(${r},${g},${b})`;
    }

    /* ---------- Input & Dragging ---------- */
    function attachPointerHandlers(el) {
      el.addEventListener('pointerdown', onPointerDown);
    }
    let pointerState = null;

    function onPointerDown(e) {
      if (state.animating) return;
      const el = e.currentTarget;
      el.setPointerCapture(e.pointerId);
      const startR = parseInt(el.dataset.r), startC = parseInt(el.dataset.c);
      
      let startX = e.clientX;
      let startY = e.clientY;
      
      // Store initial state
      pointerState = { el, startR, startC, startX, startY, id: e.pointerId };
      
      function onMove(ev) {
        if (!pointerState) return;
        const dx = ev.clientX - pointerState.startX;
        const dy = ev.clientY - pointerState.startY;
        pointerState.moved = Math.hypot(dx, dy) > 12;
      }

      function onUp(ev) {
        if (!pointerState) return;
        const dx = ev.clientX - pointerState.startX;
        const dy = ev.clientY - pointerState.startY;
        pointerState.el.releasePointerCapture(pointerState.id);
        
        const adx = Math.abs(dx), ady = Math.abs(dy);
        let targetR = pointerState.startR, targetC = pointerState.startC;
        
        // Determine swap direction
        if (Math.max(adx, ady) > 18) {
          if (adx > ady) {
            targetC = (dx > 0) ? pointerState.startC + 1 : pointerState.startC - 1;
          } else {
            targetR = (dy > 0) ? pointerState.startR + 1 : pointerState.startR - 1;
          }
          if (targetR >= 0 && targetR < state.rows && targetC >= 0 && targetC < state.cols) {
            trySwap(pointerState.startR, pointerState.startC, targetR, targetC);
          }
        }
        pointerState = null;
        window.removeEventListener('pointermove', onMove);
        window.removeEventListener('pointerup', onUp);
      }

      window.addEventListener('pointermove', onMove);
      window.addEventListener('pointerup', onUp);
    }
    
    /* ---------- Match Detection & Cascades ---------- */
    function findMatches(board) {
      const matches = new Set();
      // Horizontal
      for (let r = 0; r < state.rows; r++) {
        for (let c = 0; c <= state.cols - 3; c++) {
          if (board[r][c] === board[r][c + 1] && board[r][c + 1] === board[r][c + 2]) {
            matches.add(`${r},${c}`); matches.add(`${r},${c + 1}`); matches.add(`${r},${c + 2}`);
          }
        }
      }
      // Vertical
      for (let c = 0; c < state.cols; c++) {
        for (let r = 0; r <= state.rows - 3; r++) {
          if (board[r][c] === board[r + 1][c] && board[r + 1][c] === board[r + 2][c]) {
            matches.add(`${r},${c}`); matches.add(`${r + 1},${c}`); matches.add(`${r + 2},${c}`);
          }
        }
      }
      return Array.from(matches).map(s => {
        const [r, c] = s.split(',').map(Number);
        return { r, c };
      });
    }

    async function trySwap(r1, c1, r2, c2) {
      if (state.animating) return false;
      state.animating = true;

      swapBoardCells(r1, c1, r2, c2);
      animateSwapTiles(r1, c1, r2, c2);
      await sleep(300);
      
      const matches = findMatches(state.board);
      if (matches.length === 0) {
        animateSwapTiles(r1, c1, r2, c2, true);
        await sleep(300);
        swapBoardCells(r1, c1, r2, c2);
        state.animating = false;
        return false;
      }
      
      await resolveCascades();
      state.animating = false;
      
      if (!hasAnyValidMove()) shuffleBoard();
      checkWin();
      return true;
    }

    function swapBoardCells(r1, c1, r2, c2) {
      const tmp = state.board[r1][c1];
      state.board[r1][c1] = state.board[r2][c2];
      state.board[r2][c2] = tmp;
      
      // Update DOM grid positions
      const t1 = state.tiles.get(`${r1},${c1}`);
      const t2 = state.tiles.get(`${r2},${c2}`);
      
      if (t1) {
        t1.el.style.gridRow = `${r2 + 1} / span 1`;
        t1.el.style.gridColumn = `${c2 + 1} / span 1`;
        t1.el.dataset.r = r2;
        t1.el.dataset.c = c2;
      }
      if (t2) {
        t2.el.style.gridRow = `${r1 + 1} / span 1`;
        t2.el.style.gridColumn = `${c1 + 1} / span 1`;
        t2.el.dataset.r = r1;
        t2.el.dataset.c = c1;
      }
      
      state.tiles.set(`${r2},${c2}`, t1);
      state.tiles.set(`${r1},${c1}`, t2);
    }
    
    function animateSwapTiles(r1, c1, r2, c2, revert = false) {
      const t1 = state.tiles.get(`${r1},${c1}`);
      const t2 = state.tiles.get(`${r2},${c2}`);
      if (!t1 || !t2) return;
      
      const style1 = t1.el.style;
      const style2 = t2.el.style;
      
      style1.transition = 'transform .3s ease-in-out';
      style2.transition = 'transform .3s ease-in-out';
      
      if (!revert) {
          style1.transform = 'scale(1.1)';
          style2.transform = 'scale(1.1)';
      } else {
          style1.transform = 'scale(0.9)';
          style2.transform = 'scale(0.9)';
      }
      
      setTimeout(() => {
          style1.transform = 'scale(1)';
          style2.transform = 'scale(1)';
      }, 150);
      
      setTimeout(() => {
          style1.transition = '';
          style2.transition = '';
      }, 300);
    }

    async function resolveCascades() {
      while (true) {
        const matches = findMatches(state.board);
        if (matches.length === 0) break;
        
        await removeMatches(matches);
        await applyGravityAndRefill();
        
        persistLevel();
        updateRevealUI();
        await sleep(150);
      }
    }

    function removeMatches(cells) {
      return new Promise(res => {
        const unique = new Set(cells.map(c => `${c.r},${c.c}`));
        
        unique.forEach(key => {
          const t = state.tiles.get(key);
          if (t && t.el) {
            t.el.classList.add('vanish');
          }
          const [r, c] = key.split(',').map(Number);
          if (!state.revealedMask[r][c]) state.revealedMask[r][c] = true;
          const colorIndex = state.board[r][c];
          if (colorIndex === currentLevel().goal.colorIndex) state.collected++;
        });

        updateRevealUI();
        
        setTimeout(() => {
          unique.forEach(key => {
            const t = state.tiles.get(key);
            if (t && t.el) { t.el.remove(); }
            state.tiles.delete(key);
            const [r, c] = key.split(',').map(Number);
            state.board[r][c] = null;
          });
          res();
        }, 350);
      });
    }

    function applyGravityAndRefill() {
      return new Promise(async res => {
        const promises = [];
        for (let c = 0; c < state.cols; c++) {
          let emptyRows = [];
          for (let r = state.rows - 1; r >= 0; r--) {
            if (state.board[r][c] === null) {
              emptyRows.push(r);
            } else if (emptyRows.length > 0) {
              const oldR = r;
              const newR = emptyRows.shift();
              const oldKey = `${oldR},${c}`;
              const newKey = `${newR},${c}`;
              
              const t = state.tiles.get(oldKey);
              if (t) {
                t.el.style.gridRow = `${newR + 1} / span 1`;
                t.el.dataset.r = newR;
                
                state.board[newR][c] = state.board[oldR][c];
                state.board[oldR][c] = null;
                
                state.tiles.delete(oldKey);
                state.tiles.set(newKey, t);
              }
              emptyRows.push(oldR);
            }
          }
          
          emptyRows.sort((a,b) => a-b);
          for (let i = 0; i < emptyRows.length; i++) {
            const r = emptyRows[i];
            const color = Math.floor(Math.random() * COLORS_COUNT);
            state.board[r][c] = color;
            const tile = createTile(r, c, color);
            
            // Add to board and tiles map
            boardEl.appendChild(tile.el);
            state.tiles.set(`${r},${c}`, tile);
            
            // Animate appearance (optional but nice)
            promises.push(new Promise(resolve => {
                tile.el.style.opacity = '0';
                tile.el.style.transform = 'translateY(-100%)';
                setTimeout(() => {
                    tile.el.style.transition = 'transform .4s cubic-bezier(.2,.9,.2,1), opacity .4s ease';
                    tile.el.style.transform = 'translateY(0)';
                    tile.el.style.opacity = '1';
                }, i * 50);
                setTimeout(() => {
                    tile.el.style.transition = '';
                    resolve();
                }, 450);
            }));
          }
        }
        await Promise.all(promises);
        res();
      });
    }

    function shuffleBoard() {
      const flatTiles = Array.from(state.tiles.values());
      for (let i = flatTiles.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [flatTiles[i], flatTiles[j]] = [flatTiles[j], flatTiles[i]];
      }

      state.board = Array.from({ length: state.rows }, () => Array(state.cols).fill(null));
      state.tiles.clear();
      
      let k = 0;
      for (let r = 0; r < state.rows; r++) {
        for (let c = 0; c < state.cols; c++) {
          const tile = flatTiles[k];
          state.board[r][c] = tile.colorIndex;
          
          tile.r = r;
          tile.c = c;
          tile.el.dataset.r = r;
          tile.el.dataset.c = c;
          tile.el.style.gridRow = `${r + 1} / span 1`;
          tile.el.style.gridColumn = `${c + 1} / span 1`;
          
          state.tiles.set(`${r},${c}`, tile);
          k++;
        }
      }

      if (findMatches(state.board).length > 0) {
        shuffleBoard();
        return;
      }
    }

    function hasAnyValidMove() {
      for (let r = 0; r < state.rows; r++) {
        for (let c = 0; c < state.cols; c++) {
          const dirs = [[0, 1], [1, 0], [-1, 0], [0, -1]];
          for (const [dr, dc] of dirs) {
            const nr = r + dr, nc = c + dc;
            if (nr < 0 || nr >= state.rows || nc < 0 || nc >= state.cols) continue;
            swapBoardCells(r, c, nr, nc);
            const matches = findMatches(state.board);
            swapBoardCells(r, c, nr, nc);
            if (matches.length > 0) return true;
          }
        }
      }
      return false;
    }

    function onHint() {
      const best = findBestMoveSimple();
      if (!best) {
        alert("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Ö–æ–¥–æ–≤ ‚Äî –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –ø–µ—Ä–µ–º–µ—à–∏–≤–∞–Ω–∏–µ.");
        shuffleBoard();
        return;
      }
      const a = state.tiles.get(`${best.from[0]},${best.from[1]}`);
      const b = state.tiles.get(`${best.to[0]},${best.to[1]}`);
      if (a) a.el.style.transform = 'scale(1.2)';
      if (b) b.el.style.transform = 'scale(1.2)';
      
      setTimeout(() => {
        if (a) a.el.style.transform = 'scale(1)';
        if (b) b.el.style.transform = 'scale(1)';
      }, 700);
    }

    function findBestMoveSimple() {
      for (let r = 0; r < state.rows; r++) {
        for (let c = 0; c < state.cols; c++) {
          const dirs = [[0, 1], [1, 0], [-1, 0], [0, -1]];
          for (const [dr, dc] of dirs) {
            const nr = r + dr, nc = c + dc;
            if (nr < 0 || nr >= state.rows || nc < 0 || nc >= state.cols) continue;
            swapBoardCells(r, c, nr, nc);
            const matches = findMatches(state.board);
            swapBoardCells(r, c, nr, nc);
            if (matches.length > 0) return { from: [r, c], to: [nr, nc] };
          }
        }
      }
      return null;
    }

    function checkWin() {
      const lvl = currentLevel();
      if (state.collected >= lvl.goal.count) {
        bgImgEl.style.filter = 'brightness(1) saturate(1)';
        boardEl.classList.add('hidden');
        maskEl.classList.add('hidden');
        overlayTitle.textContent = "–£—Ä–æ–≤–µ–Ω—å –ø—Ä–æ–π–¥–µ–Ω!";
        overlayText.textContent = "–û—Ç–ª–∏—á–Ω–æ ‚Äî —Ñ–æ–Ω –ø–æ–ª–Ω–æ—Å—Ç—å—é –æ—Ç–∫—Ä—ã—Ç üéâ";
        overlayToggle(true);
      }
    }

    function overlayToggle(show) {
      if (show) {
        overlayEl.classList.add('show');
        winButtonsEl.style.display = 'flex';
      }
      else {
        overlayEl.classList.remove('show');
        winButtonsEl.style.display = 'none';
      }
    }

    function nextLevel() {
      if (state.levelIdx + 1 < levels.length) initLevel(state.levelIdx + 1);
      else {
        overlayTitle.textContent = "–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º!";
        overlayText.textContent = "–í—ã –ø—Ä–æ—à–ª–∏ –≤—Å–µ —É—Ä–æ–≤–Ω–∏.";
        overlayToggle(true);
      }
    }

    function resetProgress() {
      if (!confirm("–°–±—Ä–æ—Å–∏—Ç—å –ø—Ä–æ–≥—Ä–µ—Å—Å?")) return;
      localStorage.removeItem(STORAGE_KEY);
      initLevel(0);
    }

    function updateRevealUI() {
      for (let r = 0; r < state.rows; r++) {
        for (let c = 0; c < state.cols; c++) {
          const idx = r * state.cols + c;
          const cell = maskEl.children[idx];
          if (!cell) continue;
          if (state.revealedMask[r][c]) cell.classList.add('revealed');
          else cell.classList.remove('revealed');
        }
      }
      collectedTextEl.textContent = `${state.collected} / ${currentLevel().goal.count}`;
      const total = state.rows * state.cols;
      let revealed = state.revealedMask.flat().filter(Boolean).length;
      const pct = Math.round((revealed / total) * 100);
      revealBarEl.style.width = pct + '%';
    }

    /* ---------- Utility helpers ---------- */
    function sleep(ms) { return new Promise(res => setTimeout(res, ms)); }

    /* ---------- Start on load ---------- */
    window.addEventListener('load', () => {
      const prog = loadProgress();
      const keys = Object.keys(prog).map(k => parseInt(k)).filter(n => !isNaN(n));
      if (keys.length > 0) {
        const maxId = Math.max(...keys);
        const idx = levels.findIndex(l => l.id === maxId);
        if (idx >= 0) initLevel(idx);
        else initLevel(0);
      } else initLevel(0);
    });

    window.addEventListener('beforeunload', persistLevel);
  </script>
</body>
</html>